%!TEX root = ../00CFVZ_TOCL.tex

We recall the definition of a parity automaton, adapted to our setting.
Recall from Section~\ref{sec:onestep} that formulas of an arbitrary one-step language $\llang$ are interpreted over  one-step models, that is, a tuple $\osmodel = (D,\val: A \to \wp D)$. %Whenever we say `one-step model' in this section we will be referring to \emph{single-sorted} one-step models. 
Recall that the class of all one-step models is denoted by $\umods$ and that we write $\llang^+(A)$ to denote the fragment where every predicate $a\in A$ occurs only positively.
Without loss of generality, from now on we always assume that every bound variable occurring in a sentence is bound by an unique quantifier (generalised or not).




\begin{definition}[Parity Automata] \label{def:partityaut}
A \emph{parity automaton} based on the one-step language $\llang$ and 
alphabet $\wp(\props)$ is a tuple $\aut = \tup{A,\tmap,\pmap,a_I}$ such that $A$ is a
finite set of states, $a_I \in A$ is the initial state,
$\tmap: A\times \wp(\props) \to \llang^+(A)$
is the transition map, and $\pmap: A \to \nat$ is the parity map.
The class of such automata will be denoted by $\Aut(\llang)$.

Acceptance of a $\props$-transition
system $\model = \tup{\moddom,R,\tscolors,s_I}$ by $\aut$ is determined by the \emph{acceptance game}
$\agame(\aut,\model)$ of $\aut$ on $\model$. This is the parity game defined
according to the rules of the following table.
%
% \begin{table*}[ht]
%   \centering
\begin{center}
\small
\begin{tabular}{|l|c|l|c|} \hline
Position & Pl'r & Admissible moves & Parity \\
\hline
    $(a,s) \in A \times \moddom$
  & $\eloise$
  & $\{\val : A \to \wp(R[s]) \mid (R[s],\val) \models \tmap (a, \tscolors(s)) \}$
  & $\pmap(a)$ 
\\
%     $(a,s) \in A \times \moddom$
%   & $\abelard$
%   & $\{(a,s,\aact) \in A \times \moddom  \mid \aact \in \acts\}$
%   & $\pmap(a)$ 
% \\
%     $(a,s,\aact) \in A \times \moddom $
%   & $\eloise$
%   & $\{\val : A \to \wp(R_\aact[s]) \mid (R_\aact[s],\val) \models \tmap (a, \tscolors(s), \aact) \}$
%   & $\pmap(a)$ 
% \\
    $\val : A \rightarrow \wp(\moddom)$
  & $\abelard$
  & $\{(b,t) \mid t \in \val(b)\}$
  & $\max(\pmap[A])$
\\ \hline
 \end{tabular}
\end{center}
%
A transition system $\model$ is \emph{accepted} by $\aut$ if $\exists$ has
a winning strategy in $\agame(\aut,\model)@(a_I,s_I)$, and \emph{rejected}
if $(a_I,s_I)$ is a winning position for $\abelard$. We write $\trees(\aut)$ for the class of trees (also called the \emph{tree language}) recognised by $\bbA$.
\end{definition}

\myparagraphns{Closure under complementation.}
Many properties of parity automata can already be determined at the one-step level.
An important example concerns the notion of complementation, which will be used later in this section.


\begin{definition}
\label{d:bdual1}
Two one-step formulas $\varphi$ and $\psi$ are each other's \emph{Boolean dual}
if for every structure $(D,\val)$ we have:
\[
(D,\val) \models \varphi \quad\text{iff}\quad (D,\val^{c}) \not\models \psi,
\]
where $\val^{c}$ is the valuation given by $\val^{c}(a) \mathrel{:=} D
\setminus \val(a)$, for all $a$.
%
A one-step language $\llang$ is \emph{closed under Boolean duals} if for every
set $A$, each formula $\varphi \in \llang(A)$ has a Boolean dual $\dual{\varphi}
\in \llang(A)$.
\end{definition}

Following ideas from~\cite{Muller1987,DBLP:conf/calco/KissigV09}, we can use Boolean duals, together with a
\emph{role switch} between $\abelard$ and $\eloise$, in order to define a
negation or complementation operation on automata.

\begin{definition}
\label{d:caut}
Assume that, for some one-step language $\llang$, the map $\dual{(-)}$
provides, for each set $A$, a Boolean dual $\dual{\varphi} \in \llang(A)$ for each
$\varphi \in \llang(A)$.
Given $\aut = \tup{A,\tmap,\pmap,a_I}$ in $\Aut(\llang)$ we define its
\emph{complement} $\dual{\aut}$ as the automaton
$\tup{A,\dual{\tmap},\dual{\pmap},a_I}$
where $\dual{\tmap}(a,c) := \dual{(\tmap(a,c))}$, and $\dual{\pmap}(a)
:= 1 + \pmap(a)$, for all $a \in A$ and $c \in \wp(\props)$.
\end{definition}

\begin{proposition}
\label{prop:autcomplementation}
Let $\llang$ and $\dual{(-)}$ be as in the previous definition.
For each automaton $\aut \in \Aut(\llang)$ and each transition system
$\model$ we have that
\[
\dual{\aut} \text{ accepts } \model
\quad\text{iff}\quad
\aut \text{ rejects } \model.
\]
\end{proposition}

The proof of Proposition~\ref{prop:autcomplementation} is based on the fact
that the power of $\eloise$ in $\agame(\dual{\aut},\model)$ is the same
as that of $\abelard$ in $\agame(\aut,\model)$, as defined in~\cite{DBLP:conf/calco/KissigV09}.

As an immediate consequence of this proposition, one may show that if the
one-step language $\llang$ is closed under Boolean duals, then the class
$\Aut(\llang)$ is closed under taking complementation.
Further on we will use Proposition~\ref{prop:autcomplementation} to show that
the same may apply to some subclasses of $\Aut(\llang)$.


\myparagraphns{Weakness and Continuity.}

The automata-theoretic characterisation of $\wmso$ and $\nmso$ will use classes of parity automata constrained by two additional properties: weakness
and continuity. 

\begin{definition}%[Weakness, Continuity]
\label{def:weak}
Let $\llang$ be a one-step language, and let $\bbA = \tup{A,\tmap,\pmap,a_I}$
be in $\Aut(\llang)$. Write $\ord$ for the reachability relation in $\bbA$, i.e. the reflexive-transitive closure of $\{ (a,b) \mid \exists c. b \text{ occurs in }\tmap(a,c)\}$. A \emph{strongly connected $\ord$-component} ($\ord$-SCC) is a subset $M\subseteq A$ such that, for every $a,b \in M$ we have $a \ord b$ and $b \ord c$. The SCC is called \emph{maximal} (MSCC) when $M\cup\{a\}$ ceases to be a SCC for any choice of $a \in A\setminus M$.
%Given the semantics of the one-step language $\llang$, the (semantic) notion of (co-)continuity applies to one-step formulas (see for instance section~\ref{subsec:one-stepcont}). 
We formulate two requirements on automata from $\Aut(\llang)$:
\begin{description}
\item[(weakness)] if $a \ord b$ and $b \ord a$ then $\pmap(a) = \pmap(b)$.
\item[(continuity)] let $a,b$ be states such that both $a\ord b$ and
$b \ord a$, and let $c\in C$;
    if ${\pmap(b)}=1$ then $\tmap(b,c)$ is continuous in $a$.
    If $\pmap(b)=0$, then $\tmap(b,c)$ is co-continuous in $a$.
\end{description}
We call \emph{weak} a parity automaton $\aut \in \Aut(\llang)$ satisfying \emph{(weakness)} and $\AutW(\llang)$ the class of weak automata. We call it \emph{continuous-weak} if it additionally satisfies \emph{(continuity)}, and $\AutWC(\llang)$ the class of continuous-weak automata.
\end{definition}


Intuitively, weakness forbids an automaton to register non-trivial properties concerning the vertical `dimension' of input trees, whereas continuity expresses a constraint on how much of the horizontal `dimension' of an input tree the automaton is allowed to process. In terms of second-order logic, they correspond respectively to quantification over `vertically' finite (i.e. included in well-founded subtrees) and `horizontally' finite (i.e. included in finitely branching subtrees) sets. The conjunction of weakness and continuity thus corresponds to quantification over finite sets. 


\begin{remark}
Any weak parity automaton $\bbA$ is equivalent to a weak parity automaton
$\bbA'$ with $\pmap: A' \to \{0,1\}$. This is because \emph{(weakness)} prevents states of different parity to occur infinitely often in acceptance games, meaning that we may just assign $0$ to any even-parity and $1$ to any odd-parity state. From now on we assume such a restricted parity map for weak parity automata.
\end{remark}



The next two sections will use parity automata to characterise $\wmso$ and $\nmso$. In Section \ref{sec:autwmso} we will show $\wmso$ equivalent to $\AutWC(\olque)$ on trees. in Section \ref{sec:autnmso}, we will relate in the same way $\nmso$ and $\AutW(\ofoe)$.

%%%
