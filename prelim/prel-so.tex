Given a set of propositional letters, or predicates, $\prop$, we define three variants of monadic second-order logic on it:
\emph{(standard) monadic second-order logic} ($\mso(\prop)$),
\emph{weak monadic second-order logic} ($\wmso(\prop)$) and
\emph{noetherian monadic second-order logic} ($\nmso(\prop)$).
We omit  $\prop$ when the set of proposition letters is clear from context. 
These logics share the same syntax.
\begin{definition}\label{def:mso}
The formulas of the \emph{monadic second-order
language} on a set of predicates $\prop$ are defined by the following grammar:
%
\begin{eqnarray*}\label{EQ_mso}
  \varphi ::= \here{p} \mid p \inc q \mid R(p,q) \mid \lnot\varphi \mid \varphi\lor\varphi \mid \exists p.\varphi,
\end{eqnarray*}
where $p$ and $q$ are letters from $\prop$.
We  adopt the standard convention that no letter is both free and bound in
$\varphi$.
\end{definition}

Before giving the semantics of the three logics, we need to define what a noetherian subset of a LTS is. 
\begin{definition}
\label{d:bundle1}
Let $\model = \tup{T,R,\tscolors, s_I}$ be a LTS, and let $B$ be a non-empty set of 
finite paths that all share the same starting point $s$; we call $B$ an 
\emph{bundle rooted at} $s$, or simply an $s$-\emph{bundle}, if $B$ does not
contain an infinite ascending chain $\pi_{0} \sqsubset \pi_{1} \sqsubset 
\cdots.$
A \emph{bundle} is simply an $s$-bundle for some $s \in T$.

A subset $X$ of $T$ is called \emph{noetherian} if there is a bundle $B$ such
that each $t \in X$ lies on some path in $B$.
\end{definition}

Notice that when a LTS $\model$ is a tree, being noetherian and being included in well-founded subtree are coextensive properties of sets of nodes.

The three logics are thence distinguished by their semantics. 
Let  $\model = \tup{T,R,\tscolors, s_I}$ be a LTS, the interpretation of the
atomic formulas and the boolean connectives is fixed and standard, e.g.:
\begin{align*}
\model \models \here{p} & \quad\text{ iff }\quad  \tsval(p) = \compset{s_I} \\
\model \models p \inc q & \quad\text{ iff }\quad  \tsval(p) \subseteq \tsval(q) \\
\model \models R(p,q) & \quad\text{ iff }\quad  \text{for every $s\in \tsval(p)$ there exists $t\in \tsval(q)$ such that $sRt$} 
\end{align*}

The interpretation of the existential quantifier is that

\begin{align*}
\model \models\ \exists p. \varphi  & \quad\text{ iff }\quad  \model[p \mapsto X] \models \phi \,
\left.\begin{cases}
 \text{for some }   & {\bf (\mso)} \\
  \text{for some \emph{finite} }   & {\bf (\wmso)} \\
    \text{for some \emph{noetherian} }   & {\bf (\nmso)} 
 \end{cases}\right\}\,
 X \subseteq T.
\end{align*}
%if and only if
%\begin{description}
%%[\IEEEsetlabelwidth{$\alpha\omega \pi\theta\mu\varphi$}\IEEEusemathlabelsep]
%\item[$(\Wmso)$] $\model[p \mapsto X] \models \phi$ for some finite $S \subseteq_\omega T$
%\item[$(\Nmso)$] $\model[p \mapsto X] \models \phi$ for some noetherian
%    $X \subseteq T$.
%\end{description}

Let $\varphi\in \mso$ be a formula. We denote with $\|\varphi \|_P$ the set
of $C$-transition structures $\model$ such that $\model\models \varphi$.
The subscript $P$ is omitted when the set $P$ of proposition letters is clear
from the context.
A class $\mc{L}$ of transition systems is $\mso$\emph{-definable} if there
is a formula $\varphi \in \mso$ such that $\| \varphi \| = \mc{L}$.
We define the analogous notions for $\wmso$ and $\nmso$ in the same way.



%\begin{remark}
\subsubsection*{A digression on second-order languages.}
The reader may have expected a more standard two-sorted language for second-order logic, namely
%
$$
\varphi ::= p(x)
%\mid X(y)
\mid R(x,y)
\mid x \foeq y
\mid \neg \varphi
\mid \varphi \lor \varphi
\mid \exists x.\varphi
\mid \exists p.\varphi
$$%
where $p \in \prop$, $x,y \in \fovar$ (individual variables), %$X \in \sovar$ (second-order variables)
and $\foeq$ is the symbol for equality.   Formulas  are interpreted over LTS $\model = \tup{T,R,\tscolors, s_I}$ with a a variable assignment $\ass: \fovar \to T$, and the semantics of the language is completely standard. Depending on whether second order quantification is over all subsets, over finite subsets or over noetherian subsets, we obtain the three two-sorted variants  denoted respectively $2\mso(\prop)$, $2\wmso(\prop)$ and $2\nmso(\prop)$.

In each variant, both the one sorted and the two-sorted definitions can be proved to be equivalent, the key point of the equivalence being that a single sorted language can interpret the corresponding two-sorted language by encoding every individual variable $x \in \fovar$ as a set variable $p_x$ denoting a singleton.

\begin{fact}\label{fact:msovs2mso}
Let $\mathcal{L} \in \{\mso, \wmso, \nmso\}$ and $\prop_X:=\{p_x\mid x \in \fovar\}$.
The translation $(\cdot)^{m} : 2\mathcal{L}(\prop) \to \mathcal{L}(\prop \uplus \prop_X)$ defined as
\begin{itemize}
\item $(p(x))^m:= p_x \sqsubset p$,
\item $(R(x,y))^m:=R(p_x, p_y)$,
\item $ (x \foeq y)^m:=  p_x \sqsubset p_y \land p_y \sqsubset p_x$,
\item $(\exists p. \varphi)^m := \exists p. \varphi^m$,
\item $(\exists x. \varphi)^m:= \exists p_x. \texttt{singleton}(p_x) \land \varphi^m$,
\end{itemize}
where  
\begin{align*}
  \texttt{empty}(p) & := \forall q. (p \inc q) \\
  \texttt{singleton}(p) & := \forall q. (q \inc p \to (\texttt{empty}(q) \lor p\inc q))
\end{align*}
is such that
  \[
  \model,\ass \models \varphi \quad\text{iff}\quad \model[p_{x} \mapsto \{\ass(x)\}] \models \varphi^m.
  \]
\end{fact}

Definition~\ref{def:mso} is better suited to work with in the context of automata, whereas it is easier to use the standard two-sorted language for second-order logic when translating $\mu$-calculi into second order languages.
%, however, we choose to keep Definition~\ref{def:mso} as it will be better suited to work with in the context of automata.
%\end{remark}
