% !TEX root = ../00CFVZ_TOCL.tex

%\section{Parity automata and modal $\mu$-calculi}\label{sec:parityaut}

Throughout the rest of the section we fix, next to a set $\props$ of proposition 
letters, a one-step language $\llang$, as defined in Subsection \ref{sec:onestep-short}.
In light of the results therein, we assume that we have isolated fragments $\llang^+(A)$, $\cont{\llang}{B}(A)$ and $\cocont{\llang}{B}(A)$ consisting of one-step formulas in $\llang(A)$ that are respectively monotone, $B$-continuous and $B$-co-continuous, for $B \subseteq A$.
%we write $\llang^+(A)$ to denote the fragment of $\llang(A)$  where every predicate $a\in A$ occurs only positively, and we assume that we have isolated fragments $\cont{\llang}{A'}(A)$ and $\cocont{\llang}{A'}(A)$ consisting of one-step formulas in $\llang(A)$ that are respectively continuous and co-continuous in $A' \subseteq A$.

We first recall the definition of a general parity automaton, adapted to this
setting. 

\begin{definition}[Parity Automata] \label{def:partityaut}
A \emph{parity automaton} based on the one-step language $\llang$ and the set
$\props$ of proposition letters, or briefly: an \emph{$\llang$-automaton}, is a 
tuple $\bbA = \tup{A,\tmap,\pmap,a_I}$ such that $A$ is a finite set of states,
$a_I \in A$ is the initial state, $\tmap: A\times \wp(\props) \to \llang^+(A)$
is the transition map, and $\pmap: A \to \nat$ is the parity map.
The class of such automata will be denoted by $\Aut(\llang)$.

Acceptance of a $\props$-transition system $\model = 
\tup{\moddom,R,\tscolors,s_I}$ by $\bbA$ is determined by the \emph{acceptance 
game} $\agame(\bbA,\model)$ of $\bbA$ on $\model$. 
This is the parity game defined according to the rules of the following table.
\begin{center}
\small
\begin{tabular}{|l|c|l|c|} \hline
Position & Player & Admissible moves & Parity \\
\hline
    $(a,s) \in A \times \moddom$
  & $\eloise$
  & $\{\val : A \to \wp(R[s]) \mid (R[s],\val) \models \tmap (a, \tscolors(s)) \}$
  & $\pmap(a)$ 
\\
    $\val : A \rightarrow \wp(\moddom)$
  & $\abelard$
  & $\{(b,t) \mid t \in \val(b)\}$
  & $\max(\pmap[A])$
\\ \hline
 \end{tabular}
\end{center}
%
$\bbA$ \emph{accepts} $\model$ if $\eloise$ has a winning strategy in 
$\agame(\bbA,\model)@(a_I,s_I)$, and \emph{rejects} $\model$ if $(a_I,s_I)$ is 
a winning position for $\abelard$. 
We write $\autlang(\bbA)$ for the \emph{language} (class of transition systems) 
recognised by $\bbA$ and $\trees(\bbA)$ for the \emph{tree language} (class of 
trees) recognised by $\bbA$.
\end{definition}

\btbs
\item
Explain acceptance game in words
\etbs

% \myparagraphns{Closure under complementation.}
Many properties of parity automata can already be determined at the one-step
level.
An important example concerns the notion of complementation, which will be used
later in this section. Recall the notion of \emph{dual} of a one-step formula (Definition \ref{def:one-step}). Following ideas from~\cite{Muller1987,DBLP:conf/calco/KissigV09}, we can use duals, together with a \emph{role switch} between $\abelard$ and
$\eloise$, in order to define a negation or complementation operation on 
automata.

%\begin{definition}
%\label{d:bdual1}
%Two one-step formulas $\varphi$ and $\psi$ are each other's \emph{Boolean dual}
%if for every structure $(D,\val)$ we have $(D,\val) \models \varphi\quad
%\text{iff}\quad (D,\val^{c}) \not\models \psi$, where $\val^{c}$ is the 
%valuation given by $\val^{c}(a) \mathrel{:=} D \setminus \val(a)$, for all $a$.
%%
%A one-step language $\llang$ is \emph{closed under Boolean duals} if for every
%set $A$, each formula $\varphi \in \llang(A)$ has a Boolean dual $\dual{\varphi}
%\in \llang(A)$.
%\end{definition}



\begin{definition}
\label{d:caut}
Assume that, for some one-step language $\llang$, the map $\dual{(-)}$
provides, for each set $A$, a dual $\dual{\varphi} \in \llang(A)$ for each
$\varphi \in \llang(A)$.
We define the \emph{complement} of a given $\llang$-automaton 
$\bbA = \tup{A,\tmap,\pmap,a_I}$ as the automaton $\dual{\bbA} \isdef 
\tup{A,\dual{\tmap},\dual{\pmap},a_I}$ where $\dual{\tmap}(a,c) \isdef
\dual{(\tmap(a,c))}$, and $\dual{\pmap}(a) \isdef 1 + \pmap(a)$, for all 
$a \in A$ and $c \in \wp(\props)$.
\end{definition}

\begin{proposition}
\label{prop:autcomplementation}
Let $\llang$ and $\dual{(-)}$ be as in the previous definition.
For each $\bbA \in \Aut(\llang)$ and $\model$ we have that $\dual{\bbA}$ accepts
$\model$ if and only if $\bbA$ rejects $\model$.
\end{proposition}

The proof of Proposition~\ref{prop:autcomplementation} is based on the fact
that the power of $\eloise$ in $\agame(\dual{\bbA},\model)$ is the same
as that of $\abelard$ in $\agame(\bbA,\model)$, as defined 
in~\cite{DBLP:conf/calco/KissigV09}. 
As an immediate consequence, one may show that if the one-step language $\llang$
is closed under duals, then the class $\Aut(\llang)$ is closed under 
taking complementation.
Further on we will use Proposition~\ref{prop:autcomplementation} to show that
the same may apply to some subclasses of $\Aut(\llang)$.

The automata-theoretic characterisation of $\wmso$ and $\nmso$ will use classes 
of parity automata constrained by two additional properties.
To formulate these we first introduce the notion of a \emph{cluster}.

\begin{definition}
\label{d:wk}
\label{d:ctwk}
Let $\llang$ be a one-step language, and let $\bbA = \tup{A,\tmap,\pmap,a_I}$
be in $\Aut(\llang)$. 
Write $\ord$ for the reachability relation in $\bbA$, i.e., the transitive 
closure of $\{ (a,b) \mid b \text{ occurs in }\tmap(a,c) \text{ for 
some } c \in \wp(\props) \}$;
in case $a \ord b$ we say that $b$ is \emph{active} in $a$.
A \emph{cluster} of $\bbA$ is a cell of the equivalence relation generated by 
the relation $\ord \cup \rhd$ (i.e., the union of $\ord$ and its converse).
A cluster is called \emph{degenerate} if it consists of a  single element which
is not active in itself.
\end{definition}

Observe that any cluster of an automaton is either degenerate, or else each
of its states is active in itself and in any other state of the cluster.
Observe too that there is a natural order on clusters: we may say that one
cluster is \emph{higher} than another if each member of the second cluster
if active in each member of the first.
We may assume without loss of generality that the cluster to which the initial 
state belongs is in fact the highest cluster of the automaton.

We can now formulate the mentioned requirements on $\llang$-automata as follows.

\begin{definition}
\label{d:wk}
\label{d:ctwk}
Let $\bbA = \tup{A,\tmap,\pmap,a_I}$ be some $\llang$-automaton.
We say that $\bbA$ is \emph{weak} if $\pmap(a) = \pmap(b)$ whenever $a$ and $b$
belong to the same cluster.
For the property of \emph{continuity} we require that, for any cluster $M$, any
state $a \in M$ and any $c \in \wp\props$, we have that 
$\pmap(a) = 1$ implies $\tmap(a,c) \in \cont{\llang}{M}(A)$
and 
$\pmap(a) = 0$ implies $\tmap(a,c) \in \cocont{\llang}{M}(A)$.

We call a parity automaton $\bbA \in \Aut(\llang)$ \emph{continuous-weak} if it 
satisfies both properties, weakness and continuity.
The classes of weak and continuous-weak automata are denoted as $\AutW(\llang)$
and $\AutWC(\llang)$, respectively.
\end{definition}

% \begin{definition}
% \label{d:wk}
% \label{d:ctwk}
% Let $\llang$ be a one-step language, and let $\bbA = \tup{A,\tmap,\pmap,a_I}$
% be in $\Aut(\llang)$. Write $\ord$ for the reachability relation in $\bbA$, i.e.
% the reflexive-transitive closure of $\{ (a,b) \mid \exists c. b \text{ occurs 
% in }\tmap(a,c)\}$. 
% A \emph{strongly connected $\ord$-component} ($\ord$-SCC) is a subset $M
% \subseteq A$ such that, for every $a,b \in M$ we have $a \ord b$ and $b \ord c$.
% The SCC is called \emph{maximal} (MSCC) when $M\cup\{a\}$ ceases to be a SCC for
% any choice of $a \in A\setminus M$.
% We formulate two requirements on automata from $\Aut(\llang)$:
% \begin{description}
% \item[(weakness)] if $a \ord b$ and $b \ord a$ then $\pmap(a) = \pmap(b)$.
% \item[(continuity)] if $a \ord b$ and $b \ord a$, then for any $c\in C$:
%   \\ if ${\pmap(a)}=1$ then $\tmap(a,c)$ is syntactically continuous in $b$,
%      i.e., $\tmap(a,c) \in \cont{\llang}{b}(A)$;
%   \\ if ${\pmap(a)}=0$ then $\tmap(a,c)$ is syntactically co-continuous in $b$,
%      i.e., $\tmap(a,c) \in \cocont{\llang}{b}(A)$.
% \end{description}
% We call a parity automaton $\bbA \in \Aut(\llang)$ \emph{weak} if it satisfies
% \emph{(weakness)}, and \emph{continuous-weak} if it additionally satisfies 
% \emph{(continuity)}.
% The classes of weak and continuous-weak automata are denoted as $\AutW(\llang)$
% and $\AutWC(\llang)$, respectively.
% \end{definition}

Intuitively, weakness forbids an automaton to register non-trivial properties 
concerning the vertical `dimension' of input trees, whereas continuity expresses
a constraint on how much of the horizontal `dimension' of an input tree the 
automaton is allowed to process. 
In terms of second-order logic, they correspond respectively to quantification 
over `vertically' finite (i.e. included in well-founded subtrees) and 
`horizontally' finite (i.e. included in finitely branching subtrees) sets. 
The conjunction of weakness and continuity thus corresponds to quantification 
over finite sets. 

\begin{remark}\label{rmk:weak01}
Any weak parity automaton $\bbA$ is equivalent to a special weak automaton
$\bbA'$ with $\pmap: A' \to \{0,1\}$. 
This is because \emph{(weakness)} prevents states of different parity to occur
infinitely often in acceptance games; so we may just replace any even parity 
with $0$, and any odd parity with $1$.
We shall assume such a restricted parity map for weak parity automata.
\end{remark}


