% !TEX root = ../00CFVZ_TOCL.tex

%\section{Parity automata and modal $\mu$-calculi}\label{sec:parityaut}

The purpose of this section is to introduce the parity automata that we will use
in our proofs, together with the fixpoint languages that are the $\mu$-calculi 
corresponding to these automata.
It will be convenient to give a presentation of this framework that is parametric
in a one-step language $\llang$.

That is, throughout this section we fix, next to a set $\props$ of proposition 
letters, a one-step language $\llang$, as defined in the previous section.
We recall that we write $\llang^+(A)$ to denote the fragment of $\llang(A)$ 
where every predicate $a\in A$ occurs only positively, and we assume that 
we have isolated fragments $\cont{\llang}{A'}(A)$ and $\cocont{\llang}{A'}(A)$
consisting of one-step formulas in $\llang(A)$ that are respectively continuous
and co-continuous in $A' \subseteq A$.

\subsection{Parity automata}

We first recall the definition of a general parity automaton, adapted to this
setting. 

\begin{definition}[Parity Automata] \label{def:partityaut}
A \emph{parity automaton} based on the one-step language $\llang$ and the set
$\props$ of proposition letters, or briefly: an \emph{$\llang$-automaton}, is a 
tuple $\bbA = \tup{A,\tmap,\pmap,a_I}$ such that $A$ is a finite set of states,
$a_I \in A$ is the initial state, $\tmap: A\times \wp(\props) \to \llang^+(A)$
is the transition map, and $\pmap: A \to \nat$ is the parity map.
The class of such automata will be denoted by $\Aut(\llang)$.

Acceptance of a $\props$-transition system $\model = 
\tup{\moddom,R,\tscolors,s_I}$ by $\bbA$ is determined by the \emph{acceptance 
game} $\agame(\bbA,\model)$ of $\bbA$ on $\model$. 
This is the parity game defined according to the rules of the following table.
\begin{center}
\small
\begin{tabular}{|l|c|l|c|} \hline
Position & Player & Admissible moves & Parity \\
\hline
    $(a,s) \in A \times \moddom$
  & $\eloise$
  & $\{\val : A \to \wp(R[s]) \mid (R[s],\val) \models \tmap (a, \tscolors(s)) \}$
  & $\pmap(a)$ 
\\
    $\val : A \rightarrow \wp(\moddom)$
  & $\abelard$
  & $\{(b,t) \mid t \in \val(b)\}$
  & $\max(\pmap[A])$
\\ \hline
 \end{tabular}
\end{center}
%
$\bbA$ \emph{accepts} $\model$ if $\eloise$ has a winning strategy in 
$\agame(\bbA,\model)@(a_I,s_I)$, and \emph{rejects} $\model$ if $(a_I,s_I)$ is 
a winning position for $\abelard$. 
We write $\autlang(\bbA)$ for the \emph{language} (class of transition systems) 
recognised by $\bbA$ and $\trees(\bbA)$ for the \emph{tree language} (class of 
trees) recognised by $\bbA$.
\end{definition}

\btbs
\item
Explain acceptance game in words
\etbs

% \myparagraphns{Closure under complementation.}
Many properties of parity automata can already be determined at the one-step
level.
An important example concerns the notion of complementation, which will be used
later in this section.

\begin{definition}
\label{d:bdual1}
Two one-step formulas $\varphi$ and $\psi$ are each other's \emph{Boolean dual}
if for every structure $(D,\val)$ we have $(D,\val) \models \varphi\quad
\text{iff}\quad (D,\val^{c}) \not\models \psi$, where $\val^{c}$ is the 
valuation given by $\val^{c}(a) \mathrel{:=} D \setminus \val(a)$, for all $a$.
%
A one-step language $\llang$ is \emph{closed under Boolean duals} if for every
set $A$, each formula $\varphi \in \llang(A)$ has a Boolean dual $\dual{\varphi}
\in \llang(A)$.
\end{definition}

Following ideas from~\cite{Muller1987,DBLP:conf/calco/KissigV09}, we can use
Boolean duals, together with a \emph{role switch} between $\abelard$ and
$\eloise$, in order to define a negation or complementation operation on 
automata.

\begin{definition}
\label{d:caut}
Assume that, for some one-step language $\llang$, the map $\dual{(-)}$
provides, for each set $A$, a Boolean dual $\dual{\varphi} \in \llang(A)$ for each
$\varphi \in \llang(A)$.
We define the \emph{complement} of a given $\llang$-automaton 
$\bbA = \tup{A,\tmap,\pmap,a_I}$ as the automaton $\dual{\bbA} \isdef 
\tup{A,\dual{\tmap},\dual{\pmap},a_I}$ where $\dual{\tmap}(a,c) \isdef
\dual{(\tmap(a,c))}$, and $\dual{\pmap}(a) \isdef 1 + \pmap(a)$, for all 
$a \in A$ and $c \in \wp(\props)$.
\end{definition}

\begin{proposition}
\label{prop:autcomplementation}
Let $\llang$ and $\dual{(-)}$ be as in the previous definition.
For each $\bbA \in \Aut(\llang)$ and $\model$ we have that $\dual{\bbA}$ accepts
$\model$ if and only if $\bbA$ rejects $\model$.
\end{proposition}

The proof of Proposition~\ref{prop:autcomplementation} is based on the fact
that the power of $\eloise$ in $\agame(\dual{\bbA},\model)$ is the same
as that of $\abelard$ in $\agame(\bbA,\model)$, as defined 
in~\cite{DBLP:conf/calco/KissigV09}. 
As an immediate consequence, one may show that if the one-step language $\llang$
is closed under Boolean duals, then the class $\Aut(\llang)$ is closed under 
taking complementation.
Further on we will use Proposition~\ref{prop:autcomplementation} to show that
the same may apply to some subclasses of $\Aut(\llang)$.

The automata-theoretic characterisation of $\wmso$ and $\nmso$ will use classes 
of parity automata constrained by two additional properties.
To formulate these we first introduce the notion of a \emph{cluster}.

\begin{definition}
\label{d:wk}
\label{d:ctwk}
Let $\llang$ be a one-step language, and let $\bbA = \tup{A,\tmap,\pmap,a_I}$
be in $\Aut(\llang)$. 
Write $\ord$ for the reachability relation in $\bbA$, i.e., the transitive 
closure of $\{ (a,b) \mid b \text{ occurs in }\tmap(a,c) \text{ for 
some } c \in \wp(\props) \}$;
in case $a \ord b$ we say that $b$ is \emph{active} in $a$.
A \emph{cluster} of $\bbA$ is a cell of the equivalence relation generated by 
the relation $\ord \cup \rhd$ (i.e., the union of $\ord$ and its converse).
A cluster is called \emph{degenerate} if it consists of a  single element which
is not active in itself.
\end{definition}

Observe that any cluster of an automaton is either degenerate, or else each
of its states is active in itself and in any other state of the cluster.
Observe too that there is a natural order on clusters: we may say that one
cluster is \emph{higher} than another if each member of the second cluster
if active in each member of the first.
We may assume without loss of generality that the cluster to which the initial 
state belongs is in fact the highest cluster of the automaton.

We can now formulate the mentioned requirements on $\llang$-automata as follows.

\begin{definition}
\label{d:wk}
\label{d:ctwk}
Let $\bbA = \tup{A,\tmap,\pmap,a_I}$ be some $\llang$-automaton.
We say that $\bbA$ is \emph{weak} if $\pmap(a) = \pmap(b)$ whenever $a$ and $b$
belong to the same cluster.
For the property of \emph{continuity} we require that, for any cluster $M$, any
state $a \in M$ and any $c \in \wp\props$, we have that 
$\pmap(a) = 1$ implies $\tmap(a,c) \in \cont{\llang}{M}(A)$
and 
$\pmap(a) = 0$ implies $\tmap(a,c) \in \cocont{\llang}{M}(A)$.

We call a parity automaton $\bbA \in \Aut(\llang)$ \emph{continuous-weak} if it 
satisfies both properties, weakness and continuity.
The classes of weak and continuous-weak automata are denoted as $\AutW(\llang)$
and $\AutWC(\llang)$, respectively.
\end{definition}

% \begin{definition}
% \label{d:wk}
% \label{d:ctwk}
% Let $\llang$ be a one-step language, and let $\bbA = \tup{A,\tmap,\pmap,a_I}$
% be in $\Aut(\llang)$. Write $\ord$ for the reachability relation in $\bbA$, i.e.
% the reflexive-transitive closure of $\{ (a,b) \mid \exists c. b \text{ occurs 
% in }\tmap(a,c)\}$. 
% A \emph{strongly connected $\ord$-component} ($\ord$-SCC) is a subset $M
% \subseteq A$ such that, for every $a,b \in M$ we have $a \ord b$ and $b \ord c$.
% The SCC is called \emph{maximal} (MSCC) when $M\cup\{a\}$ ceases to be a SCC for
% any choice of $a \in A\setminus M$.
% We formulate two requirements on automata from $\Aut(\llang)$:
% \begin{description}
% \item[(weakness)] if $a \ord b$ and $b \ord a$ then $\pmap(a) = \pmap(b)$.
% \item[(continuity)] if $a \ord b$ and $b \ord a$, then for any $c\in C$:
%   \\ if ${\pmap(a)}=1$ then $\tmap(a,c)$ is syntactically continuous in $b$,
%      i.e., $\tmap(a,c) \in \cont{\llang}{b}(A)$;
%   \\ if ${\pmap(a)}=0$ then $\tmap(a,c)$ is syntactically co-continuous in $b$,
%      i.e., $\tmap(a,c) \in \cocont{\llang}{b}(A)$.
% \end{description}
% We call a parity automaton $\bbA \in \Aut(\llang)$ \emph{weak} if it satisfies
% \emph{(weakness)}, and \emph{continuous-weak} if it additionally satisfies 
% \emph{(continuity)}.
% The classes of weak and continuous-weak automata are denoted as $\AutW(\llang)$
% and $\AutWC(\llang)$, respectively.
% \end{definition}

Intuitively, weakness forbids an automaton to register non-trivial properties 
concerning the vertical `dimension' of input trees, whereas continuity expresses
a constraint on how much of the horizontal `dimension' of an input tree the 
automaton is allowed to process. 
In terms of second-order logic, they correspond respectively to quantification 
over `vertically' finite (i.e. included in well-founded subtrees) and 
`horizontally' finite (i.e. included in finitely branching subtrees) sets. 
The conjunction of weakness and continuity thus corresponds to quantification 
over finite sets. 

\begin{remark}\label{rmk:weak01}
Any weak parity automaton $\bbA$ is equivalent to a special weak automaton
$\bbA'$ with $\pmap: A' \to \{0,1\}$. 
This is because \emph{(weakness)} prevents states of different parity to occur
infinitely often in acceptance games; so we may just replace any even parity 
with $0$, and any odd parity with $1$.
We shall assume such a restricted parity map for weak parity automata.
\end{remark}

\subsection{$\mu$-Calculi}

We now see how to associate, with each one-step language $\llang$, the following
variant of the modal $\mu$-calculus.

\begin{definition}
Given a one-step language $\llang$, we define the language $\mu\llang$ of the 
\emph{$\mu$-calculus over $\llang$}  by the following grammar:
% \[
% \varphi ::= q \mid \neg\varphi \mid \varphi\lor\varphi 
%    \mid \nxt{\al}(\varphi_{1},\ldots,\varphi_{n})
%    \mid \mu p. \varphi',
% \]
\[
\varphi ::= 
   q \mid \neg q 
   \mid \varphi\lor\varphi \mid \varphi\land\varphi 
   \mid \nxt{\al}(\varphi_{1},\ldots,\varphi_{n})
   \mid \mu p. \varphi'    \mid \nu p. \varphi',
\]
where $p,q \in\props$, $\al(a_{1},\ldots,a_{n}) \in \llang^{+}$ and $\varphi'$ 
is monotone in $p$.

We will freely use standard syntactic concepts and notations related to this 
language, such as the sets $\FV(\phi)$ and $\BV(\phi)$ of \emph{free} and 
\emph{bound} variables of $\phi$, and the collection $\Sfor(\phi)$ of subformulas
of $\phi$.
\end{definition}

Observe that the language $\mu\llang$ generally has a wealth of modalities:
one for each one-step formula in $\llang$.

The semantics of this language is given as follows.

\begin{definition}
Let $\model$ be a transition system.
The satisfaction relation $\mmodels$ is defined in the standard way, with the 
following clause for the modality $\nxt{\alpha}$:
$$
\model \mmodels \nxt{\al}(\varphi_{1},\ldots,\varphi_{n})
\quad\text{iff}\quad 
(R[s_{I}],V_{\overline{\varphi}}) \models \al(a_{1},\ldots,a_{n}),
$$
where $V_{\overline{\varphi}}$ is the one-step valuation given by 
\[
V_{\overline{\varphi}}(a_{i}) \isdef 
  \{ t \in R[s_{I}] \mid \model.t \mmodels \varphi_{i}\}.
\]
\end{definition}

% \begin{example}
% 
% \end{example}

\btbs
\item
give some examples ($\Diamond$, $\Box$, $\Diamond^{\geq 2}$, 
$\Diamond^{\infty}$, \ldots)
\item
remark that $\nxt{\alpha\land\beta}(\ol{\phi})$ is equivalent to
$\nxt{\alpha}(\ol{\phi}) \land \nxt{\beta}(\ol{\phi})$
\item
remark about nnf \& closure under negation in case the one-step 
language is closed under taking boolean duals.
\etbs

Alternatively but equivalently, one may interpret the language
game-theoretically.

\begin{definition}
Given a $\mu\llang$-formula $\phi$ and a model $\model$ we define the 
\emph{evaluation game} $\egame(\varphi,\model)$ as the two-player infinite
game of which the rules are given in the table below.
% Table~\ref{tab:EGL}.
For the admissible moves at a position of the form 
$(\nxt{\al}(\varphi_{1},\ldots,\varphi_{n}),s)$, we consider the valuation 
$V^{*}_{Z}: \{ a_{1}, \ldots, a_{n} \} \to \wp(R[s])$, given by
$V^{*}_{Z}(a_{i}) \isdef \{ t \in R[s] \mid (\phi_{i},t) \in Z \}$.
%
\begin{table}[htb]
\centering
\begin{tabular}{|l|c|l|c|}
\hline
Position & Player & Admissible moves
\\\hline
    $(q,s)$, with $q \in \FV(\phi) \cap \tscolors(s)$ 
  & $\abelard$ 
  & $\emptyset$
\\  $(q,s)$, with $q \in \FV(\phi) \setminus \tscolors(s)$ 
  & $\eloise$ & $\emptyset$
\\  $(\lnot q,s)$, with $q \in \FV(\phi) \cap \tscolors(s)$ 
  & $\eloise$ 
  & $\emptyset$
\\  $(\lnot q,s)$, with $q \in \FV(\phi) \setminus \tscolors(s)$ 
  & $\abelard$ 
  & $\emptyset$
\\ $(\psi_1 \lor \psi_2,s)$ 
  & $\eloise$ 
  & $\{(\psi_1,s),(\psi_2,s) \}$ 
\\  $(\psi_1 \land \psi_2,s)$ 
  & $\abelard$ 
  & $\{(\psi_1,s),(\psi_2,s) \}$ 
\\  $(\nxt{\al}(\varphi_{1},\ldots,\varphi_{n}),s)$ 
  & $\eloise$ 
  & $\{ Z \sse \{ \varphi_{1},\ldots,\varphi_{n} \} \times R[s]
     \mid (R[s],V^{*}_{Z}) \models \al(\ol{a}) \}$ 
\\  $Z \sse  \Sfor(\phi) \times S$
  & $\abelard$
  & $\{ (\psi, s) \mid (\psi,s) \in Z \}$
\\  $(\mu p.\varphi,s)$ & $-$ & $\{(\varphi,s) \}$ 
\\  $(\nu p.\varphi,s)$ & $-$ & $\{(\varphi,s) \}$ 
\\  $(p,s)$, with $p \in \FV(\phi)$ & $-$ & $\{(\delta_p,s) \}$ \\
  \hline
\end{tabular}
% \caption{Evaluation game for $\mu\llang$}
% \caption{}
\label{tab:EGL}
\end{table}
The winning conditions of $\egame(\varphi,\model)$ are standard: $\eloise$ wins
those infinite matches of which the highest variable that is unfolded infinitely
often during the match is a $\mu$-variable.
\end{definition}

The following proposition, 
stating the adequacy of the evaluation game for the semantics of $\mu\llang$,
is formulated explicitly for future reference.
We omit the proof, which is completely routine.

\begin{fact}[Adequacy]
\label{f:adeqmu}
For any formula $\phi \in \mu\llang$ and any model $\model$ the following 
equivalence holds:
\[
\model \mmodels \phi
\quad\text{iff}\quad 
(\phi,s_{I}) \text{ is a winning position for $\eloise$ in } 
\egame(\varphi,\model).
\]
\end{fact}

We will be specifically interested in two fragments of $\mu\llang$, associated 
with the properties of being noetherian and continuous, respectively, and with 
the associated variants of the $\mu$-calculus $\mu\llang$ where the use of the 
fixpoint operator $\mu$ is restricted to formulas belonging to these two
respective fragments.

\begin{definition}
Let $\qprops$ be a set  of proposition letters.
We first define the fragment $\noe{\mu\llang}{\qprops}$ of $\mu\llang$ of 
formulas that are syntactically \emph{noetherian} in $\qprops$ by the following 
grammar:
\begin{equation*}
   \varphi ::= q
   \mid \psi
   \mid \varphi \lor \varphi
   \mid \varphi \land \varphi
   \mid \nxt{\al}(\varphi_{1},\ldots,\varphi_{n})
   \mid \mu p.\phi'
\end{equation*}
where $q \in \qprops$, $\psi$ is a $\qprops$-free $\MC$-formula,
$\al(a_{1},\ldots,a_{n}) \in \llang^{+}$ and 
$\phi' \in \noe{\mu\llang}{\qprops\cup\{p\}}$. 
The \emph{co-noetherian} fragment $\conoe{\mu\llang}{Q}$ is defined dually.

Similarly, we define the fragment $\cont{\mu\llang}{\qprops}$ of 
$\mu\llang$-formulas that are syntactically \emph{continuous} in $\qprops$ as
follows:
\begin{equation*}
   \varphi ::= q
   \mid \psi
   \mid \varphi \lor \varphi
   \mid \varphi \land \varphi
   \mid 
   \nxt{\al}(\varphi_{1},\ldots,\varphi_{k},\psi_{1},\ldots,\psi_{m})
   \mid \mu p.\phi'
\end{equation*}
where $p\in\props$, $q \in \qprops$, $\psi$, $\psi_{i}$ are $\qprops$-free 
$\MC$-formula, $\al(a_{1},\ldots,a_{k},b_{1},\ldots,b_{m}) \in 
\cont{\llang}{\ol{a}}(\ol{a},\ol{b})$,
and $\phi' \in \cont{\mu\llang}{\qprops\cup\{p\}}$. 
The \emph{co-continuous} fragment $\cocont{\mu\llang}{Q}$ is defined dually.
\end{definition}

Based on this we can now define the mentioned variants 
% $\mu_{D}\llang$ and $\mu_{C}\llang$ 
of the $\mu$-calculus $\mu\llang$ where the use of the least (greatest) 
fixpoint operator can only be applied to formulas that belong to, 
respectively, the noetherian (co-noetherian) and continuous (co-continuous)
fragment of the language that we are defining.

\begin{definition}
The formulas of the \emph{alternation-free} $\mu$-calculus $\mu_{D}\llang$ 
are defined by the following grammar:
\begin{equation*}
   \varphi ::= 
      q \mid \neg q 
   \mid \varphi\lor\varphi \mid \varphi\land\varphi 
   \mid \nxt{\al}(\varphi_{1},\ldots,\varphi_{n})
   \mid \mu p. \varphi'    
   \mid \nu p. \varphi'',
\end{equation*} 
where $\al(a_{1},\ldots,a_{n}) \in \llang^{+}$,
$\phi' \in \mu_{D}\llang \cap \noe{\mu\llang}{p}$
and dually $\phi'' \in \mu_{D}\llang \cap \conoe{\mu\llang}{p}$.

Similarly, the formulas of the \emph{continuous} $\mu$-calculus $\mu_{C}\llang$
are given by the grammar
\begin{equation*}
   \varphi ::= 
      q \mid \neg q 
   \mid \varphi\lor\varphi \mid \varphi\land\varphi 
   \mid \nxt{\al}(\varphi_{1},\ldots,\varphi_{n})
   \mid \mu p. \varphi'    
   \mid \nu p. \varphi'',
\end{equation*} 
where $\al(a_{1},\ldots,a_{n}) \in \llang^{+}$,
$\phi' \in \mu_{C}\llang \cap \cont{\mu\llang}{p}$
and dually $\phi'' \in \mu_{C}\llang \cap \cocont{\mu\llang}{p}$.
\end{definition}


%%%
